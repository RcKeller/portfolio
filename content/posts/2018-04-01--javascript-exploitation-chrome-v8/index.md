---
title: JavaScript Exploitation in Chrome V8
subtitle: Capstone: Traversing execution environments and VM sandboxing.
category: Portfolio
cover: javascript-exploitation-chrome-v8.png
---

Shout out to my colleagues who worked with me on this project:

- [Ali Shubber](https://github.com/alishubber) - Security Engineer at T-Mobile
- [Muhammad Hussain](https://github.com/mnh78614) - UI/UX Designer, Starbucks

---

This project is many things, most importantly:
- An exploit of Chrome's browser environment and internal API
- The exploit weaponized within a chrome extension
- A system for performing automated pentesting by leveraging said exploit.

## The Exploit

Chrome is reputed as one of the most secure web browsers due to its built-in security features. Under the hood Chrome uses the [V8 Engine](https://developers.google.com/v8/) (also used by Node.js!) and spawns several separate runtime environments for each website and extension. These "[Execution Environments](https://developer.chrome.com/extensions/content_scripts#execution-environment)" are silo'd off from each other, except for [built-in methods](https://developer.chrome.com/extensions/sandboxingEval) that evaluate code after it is aggressively sanitized.

However, the sanitizer only blocks overt attempts at evaluating unsafe code, so it's possible to circumvent by abstracting out some of the evaluation logic. This can be done by leveraging the `Window.postMessage` API to add an exploit to the DOM as a self-executing script tag that deletes itself, thus `eval` never has to be used for the script to be interpreted.

It's a little complicated, but it's documented in the [project](https://github.com/RcKeller/security-extension/blob/master/extension/app/core/DOM.js#L14) and we'll go through it step by step:

### Step 1. Prepare an exploit script
**Environment:** Background Script (Chrome Extension)

Start with an exploit. Something that logs global variables outside of the vanilla JS API is a good start:

```js
/*
Name:         Get Global State
Version:      1.0
Author:       Ryan Keller
Description:  Find all unique, application-specific variables
*/
const jsAPI = ['top', 'window', 'location', 'external', 'chrome', 'document', 'inlineCSS', 'target', 'width', 'height', 'canvas', 'data', 'DOMURL', 'img', 'svg', 'ctx', 'url', 'w', 'a', 'speechSynthesis', 'webkitNotifications', 'localStorage', 'sessionStorage', 'applicationCache', 'webkitStorageInfo', 'indexedDB', 'webkitIndexedDB', 'crypto', 'CSS', 'performance', 'console', 'devicePixelRatio', 'styleMedia', 'parent', 'opener', 'frames', 'self', 'defaultstatus', 'defaultStatus', 'status', 'name', 'length', 'closed', 'pageYOffset', 'pageXOffset', 'scrollY', 'scrollX', 'screenTop', 'screenLeft', 'screenY', 'screenX', 'innerWidth', 'innerHeight', 'outerWidth', 'outerHeight', 'offscreenBuffering', 'frameElement', 'clientInformation', 'navigator', 'toolbar', 'statusbar', 'scrollbars', 'personalbar', 'menubar', 'locationbar', 'history', 'screen', 'postMessage', 'close', 'blur', 'focus', 'ondeviceorientation', 'ondevicemotion', 'onunload', 'onstorage', 'onresize', 'onpopstate', 'onpageshow', 'onpagehide', 'ononline', 'onoffline', 'onmessage', 'onhashchange', 'onbeforeunload', 'onwaiting', 'onvolumechange', 'ontimeupdate', 'onsuspend', 'onsubmit', 'onstalled', 'onshow', 'onselect', 'onseeking', 'onseeked', 'onscroll', 'onreset', 'onratechange', 'onprogress', 'onplaying', 'onplay', 'onpause', 'onmousewheel', 'onmouseup', 'onmouseover', 'onmouseout', 'onmousemove', 'onmouseleave', 'onmouseenter', 'onmousedown', 'onloadstart', 'onloadedmetadata', 'onloadeddata', 'onload', 'onkeyup', 'onkeypress', 'onkeydown', 'oninvalid', 'oninput', 'onfocus', 'onerror', 'onended', 'onemptied', 'ondurationchange', 'ondrop', 'ondragstart', 'ondragover', 'ondragleave', 'ondragenter', 'ondragend', 'ondrag', 'ondblclick', 'oncuechange', 'oncontextmenu', 'onclose', 'onclick', 'onchange', 'oncanplaythrough', 'oncanplay', 'oncancel', 'onblur', 'onabort', 'onwheel', 'onwebkittransitionend', 'onwebkitanimationstart', 'onwebkitanimationiteration', 'onwebkitanimationend', 'ontransitionend', 'onsearch', 'getSelection', 'print', 'stop', 'open', 'showModalDialog', 'alert', 'confirm', 'prompt', 'find', 'scrollBy', 'scrollTo', 'scroll', 'moveBy', 'moveTo', 'resizeBy', 'resizeTo', 'matchMedia', 'requestAnimationFrame', 'cancelAnimationFrame', 'webkitRequestAnimationFrame', 'webkitCancelAnimationFrame', 'webkitCancelRequestAnimationFrame', 'captureEvents', 'releaseEvents', 'atob', 'btoa', 'setTimeout', 'clearTimeout', 'setInterval', 'clearInterval', 'TEMPORARY', 'PERSISTENT', 'getComputedStyle', 'getMatchedCSSRules', 'webkitConvertPointFromPageToNode', 'webkitConvertPointFromNodeToPage', 'webkitRequestFileSystem', 'webkitResolveLocalFileSystemURL', 'openDatabase', 'addEventListener', 'removeEventListener', 'dispatchEvent']
let globals = {}
Object.keys(window).forEach((global) => {
  if (jsAPI.includes(global) === false) {
    globals[global] = global
  }
})
RETURN(globals)
```

This needs to be recorded as a string, to avoid escaping everything, use [raw string literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw).

```js
//  ES6 black magic
String.raw`console.log('no',"need",`to`,'escape',"anything")`;
```

### Step 1: Wrap the exploit as a browser event
**Environment:** Background Script (Chrome Extension)

We can circumvent using `eval`, which is sanitized, by creating `<script>` tags in the DOM itself. To make our exploit even more discrete, we're going to wrap the malicious script with code that creates a self-executing function that deletes itself once it runs. Crafty.

Save this function as another raw string:

```js
function RAW_DOM_INJECTION (script = {}) {
  return new Promise((resolve, reject) => {
    try {
      /* EXECUTION ENVIRONMENT: RAW DOM -> CONTENT SCRIPT */
      window.addEventListener(script.id, (e) => {
        /* EXECUTION ENVIRONMENT: CONTENT SCRIPT -> BACKGROUND (EXTENSION) */
        const { detail } = e
        resolve(detail)
      }, { once: true })
      /* EXECUTION ENVIRONMENT: CONTENT SCRIPT -> RAW DOM */
      const element = document.createElement('script')
      element.textContent = '(async function () {' +
        'const execution = () => new Promise((RETURN, ERROR) => { ' + script.code + ' });' +
        'let response = await execution();' +
        'var event = document.createEvent("CustomEvent");' +
        'event.initCustomEvent("' + script.id + '", true, true, response);' +
        'window.dispatchEvent(event);' +
      '})();';
      /* EXECUTION ENVIRONMENT: CONTENT SCRIPT -> RAW DOM */
      (document.head || document.documentElement).appendChild(element)
      element.parentNode.removeChild(element)
    } catch (ERROR) {
      console.error(ERROR)
      resolve({ ERROR })
    }
  })
}
```

You may wonder why we're wrapping this as an event - this is so we can listen for the output of the script! Our background scripts run in a different VM environment so we can't access the return values of scripts running in the page, BUT we can listen for an event with a unique ID and intercept output that way!

### Step 2. Execute the script through Chrome APIs

Use the native chrome API methods like `chrome.tabs.executeScript` or `chrome.tabs.executeScriptAsync` (if your script returns a promise) to evaluate the wrapped exploit [like so](https://github.com/RcKeller/security-extension/blob/master/extension/app/ducks/pages.js#L56), and watch the magic happen.

Here's everything that happens in chronological order:

- The extension creates events using the content script environment, which has DOM access.
- Background sends a script for execution
- The content script defines an event listener based on the script ID
- A script tag wrapping the exploit is made
  - It wraps the function, ideally with a promise
  - Create and dispatch an event listener, passing the promise a return value
- Inject the script, which executes immediately
- Remove the script tag to hide the evidence.
- Function executes in RAW DOM, dispatches event, then falls out of scope. Poof.
- Event listener passes a message back the the BACKGROUND, our extension.

Voila! The exploit should run successfully, and delete any trace of its being there.

## Conclusion

By exploiting what we know about Chrome security and the V8 engine, we can effectively traverse environments using internal APIs in a unique and creative way. This attack requires a consenting user running our scripts as a chrome extension, and isn't a viable attack for unsuspecting users. Rather, it's best used by the informed as a penetration testing tool. I use this exploit to perform static analysis of websites as I browse the web.

This exploit and the weaponized extension are all open source and will never be for-profit, and I highly encourage you to check it out on [my GitHub](https://github.com/RcKeller/security-extension) and contribute if you're interested!
